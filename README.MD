# 📘 React Hooks 정리

## 🔹 useState()

> `useState`는 React 함수형 컴포넌트에서 상태(state)를 관리할 수 있도록 해주는 Hook입니다.

- 클래스형 컴포넌트의 `this.state`와 `this.setState`를 대체합니다.
- 상태 변수를 선언하고 해당 상태를 업데이트하는 함수를 제공합니다.
- 컴포넌트가 렌더링될 때마다 상태를 유지합니다.
- 변수 각각에 대한 `set` 함수가 따로 존재합니다.

### useState 관련 용어

- **state**: 현재 상태 값  
  `useState`로 관리되는 상태 값입니다. 이 값은 컴포넌트에서 언제든지 접근할 수 있습니다.

- **setState**: 상태를 변경하는 함수  
  `setState` 함수는 상태 값을 업데이트하는 데 사용됩니다. 상태 변경 시 컴포넌트가 리렌더링됩니다.

- **initialValue**: 상태의 초기 값  
  `useState`에 전달되는 첫 번째 인자는 상태의 초기 값입니다. 이 값은 컴포넌트가 처음 렌더링될 때 사용됩니다.


### 상태 관리 예시

| 기능               | 코드 예시                                       |
|--------------------|------------------------------------------------|
| **기본 사용**      | `const [state, setState] = useState(초기값);`   |
| **상태 변경**      | `setState(새로운 값)`                           |
| **객체 상태 관리** | `setState(prev => ({ ...prev, 변경값 }))`      |
| **배열 상태 관리** | `setState([...배열, 새 요소])`                 |
| **함수형 업데이트**| `setState(prev => prev + 1)`                   

# 🪝 useEffect Hook in React

## 🔍 개요
- `useEffect`는 React Hook 중 하나로, 컴포넌트를 외부 시스템과 동기화할 수 있도록 해줍니다.
- `useEffect()` Hook은 함수형 컴포넌트 내에서 **부수 효과(side effect)** 를 수행할 수 있도록 해줍니다.

## ❓ 부수 효과란?
- **부수 효과(Side Effect)** 는 컴포넌트의 주요 기능 외에 추가적으로 실행되는 작업을 의미합니다.
- 대표적인 예:
  - 데이터 fetching
  - 구독(subscribe)
  - DOM 직접 조작
  - 타이머 설정 등

## 🔄 클래스형 컴포넌트 대체
- 클래스형 컴포넌트의 다음 메서드들을 대체합니다:
  - `componentDidMount`
  - `componentDidUpdate`
  - `componentWillUnmount`

## 🧠 사용법

```js
useEffect(setup, dependencies?)
```
- setup: 실행할 함수
- dependencies: 의존성 배열 → 특정 값이 변경될 때만 실행

# 📋 useEffect 사용법 정리

| 실행 조건                 | 코드 예시                                | 설명                                                                 |
|--------------------------|------------------------------------------|----------------------------------------------------------------------|
| 처음 한 번만 실행        | `useEffect(() => { ... }, [])`           | 컴포넌트 **마운트 시 1회 실행**, 의존성 배열이 빈 배열               |
| 특정 상태 변경 시 실행   | `useEffect(() => { ... }, [state])`      | `state` 값이 **변경될 때마다 실행**                                  |
| 매 렌더링마다 실행       | `useEffect(() => { ... })`               | 의존성 배열이 없으면 **모든 렌더링마다 실행**                         |
| 언마운트 시 정리(cleanup)| `useEffect(() => { return () => { ... }; }, [])` | 컴포넌트 **언마운트 시 1회 실행 (정리용)**                        |

# 🧠 useMemo

## 📌 개요
- `useMemo`는 React Hook 중 하나로, **렌더링 사이에 계산 결과를 캐싱**할 수 있게 해줍니다.
- `useMemo()` Hook은 **memoization된 값을 반환**합니다.

## ❓ Memoization이란?
- **Memoization**은 특정 값을 계산하는 함수를 호출했을 때,
  - 해당 함수의 **인수가 변경되지 않았다면**, 
  - **이전에 계산된 값을 재사용**하는 최적화 기법입니다.
- `useMemo`는 **컴포넌트가 다시 렌더링될 때마다 불필요한 계산을 방지**하여 성능을 향상시킵니다.

---

## 🧪 기본 사용법

```js
const cachedValue = useMemo(calculateValue, dependencies);
const memoizedValue = useMemo(() => {
return 계산할 값;
}, [의존성 배열]);
```
첫 번째 인자: 계산할 함수 (값을 반환하는 함수)
두 번째 인자: 의존성 배열 ([])
배열 내 값이 변경될 때만 함수가 실행됨
값이 변경되지 않으면 이전 결과를 재사용
---
# 🧠 useMemo 

## 📌 개요
- `useMemo`는 React Hook 중 하나로, **렌더링 사이에 계산 결과를 캐시**합니다.
- `useMemo()` Hook은 **memoization된 값을 반환**합니다.

---

## ❓ Memoization이란?
- ** Memoization **은 동일한 입력값에 대해 이전에 계산된 결과를 재사용하여 **불필요한 재계산을 방지**하는 최적화 기법입니다.
- React 컴포넌트가 렌더링될 때마다 동일한 계산을 반복하는 비용을 줄일 수 있습니다.

---

## 🧪 기본 사용법

```js
const memoizedValue = useMemo(
  () => computeExpensiveValue(a, b),
  [a, b]
);
```
---

### useMemo()

`useMemo`는 계산 비용이 큰 연산의 결과를 메모이제이션하여 성능을 최적화하는 Hook입니다.

#### ✅ 사용해야 하는 경우
- 연산 비용이 큰 계산을 반복할 때
- 객체 또는 배열이 불필요하게 재생성될 때
- 의존성이 변경되지 않는 한 동일한 값을 유지해야 할 때

#### ❌ 사용하지 않아도 되는 경우
- 간단한 연산
- 값이 자주 바뀌는 경우 (오히려 성능 저하 가능)
- `useEffect`와 혼동하여 잘못 사용하는 경우

#### ⚠️ 사용 시 주의사항
- 과도한 사용은 오히려 성능 저하를 유발할 수 있습니다.
- 의존성 배열을 정확하게 지정할 것

---

# 🔁 useCallback Hook in React

## 📌 개요
- `useCallback`은 React Hook 중 하나로, **함수 정의를 렌더링 간에 캐싱**할 수 있게 해줍니다.
- `useCallback()` Hook은 **함수의 메모이제이션**을 제공합니다.

---

## ❓ Memoization이란?
- **메모이제이션(Memoization)**은 특정 함수를 호출했을 때,
  - 그 **인자가 변경되지 않았다면**,  
  - **이전에 생성된 함수를 재사용**하는 최적화 기법입니다.

- 이로 인해, 컴포넌트가 다시 렌더링되더라도 동일한 함수가 **불필요하게 다시 생성되지 않도록** 방지할 수 있습니다.

---

# 🔁 useCallback Hook in React

## 📌 개요
- `useCallback`은 React Hook 중 하나로, **함수 정의를 메모이제이션**하여 렌더링 시 동일한 함수가 **불필요하게 재생성되지 않도록** 방지합니다.
- 주로 **성능 최적화** 목적에 사용됩니다.

---

## 🕵️ 언제 `useCallback`을 사용해야 할까?

### ✅ 사용해야 하는 경우

| 상황 | 설명 |
|------|------|
| 자식 컴포넌트에 함수(props) 전달 시 | 자식 컴포넌트가 `React.memo`를 사용하고 있다면, 동일한 함수 인스턴스를 유지해야 불필요한 렌더링을 방지할 수 있음 |
| 이벤트 핸들러가 불필요하게 재생성될 때 | 동일한 로직의 핸들러 함수가 렌더링마다 새로 만들어지는 것을 방지 |
| 의존성이 자주 바뀌지 않을 때 | 의존성이 자주 바뀌면 `useCallback`의 이점이 줄어들 수 있음 |

---

### 🚫 사용하지 않아도 되는 경우

| 상황 | 설명 |
|------|------|
| 단순한 함수일 때 | 연산 비용이 낮은 함수는 메모이제이션이 오히려 불필요함 |
| 함수를 자주 생성해도 무방할 때 | 실제 렌더링이나 성능에 큰 영향을 주지 않을 경우에는 사용하지 않아도 됨 |
| 과도한 사용 | 모든 함수를 `useCallback`으로 감싸는 것은 오히려 성능을 저하시킬 수 있음 |

---

## ⚠️ `useCallback` 사용 시 주의 사항

| 항목 | 설명 |
|------|------|
| 과도한 사용 주의 | **모든 함수**에 적용하는 것은 불필요하며, **필요한 경우에만** 사용하는 것이 좋습니다. |
| 의존성 배열 정확히 지정 | 의존성 배열이 올바르지 않으면 메모이제이션이 잘못 동작하거나, 오래된 값을 참조할 수 있습니다. |
| 순수 함수 유지 | `useCallback`에 넘기는 함수는 외부 상태를 변경하지 않는 **순수 함수**여야 합니다. |

---

## ✅ `useCallback`의 장점

| 항목 | 설명 |
|------|------|
| 렌더링 성능 최적화 | 함수 재생성을 줄여 React의 리렌더링 비용을 절감할 수 있습니다. |
| 메모리 절약 | 동일한 함수 객체를 재사용함으로써 **불필요한 메모리 사용을 줄입니다.** |
| 자식 컴포넌트 최적화 | `React.memo`를 사용하는 자식 컴포넌트와 함께 사용하면 렌더링 효율이 극대화됩니다. |

---

# 🔗 useRef Hook in React

## 📌 개요
- `useRef`는 React Hook 중 하나로, **렌더링에 필요하지 않은 값을 참조하거나 유지**할 수 있게 해줍니다.
- `useRef()`는 **변경 가능한 ref 객체**를 반환하며, 이 객체는 `.current` 속성을 통해 값을 저장하거나 DOM 요소에 직접 접근할 수 있습니다.

---

## 🔍 Reference란?
- **Reference**는 특정 **컴포넌트나 DOM 요소에 접근**할 수 있는 객체를 의미합니다.
- `refObject.current`: 현재 참조 중인 값이나 DOM Element

---
```js
const ref = useRef(initialValue)
```

initialValue: useRef가 초기화될 때 설정할 값입니다. 이 값은 current 프로퍼티에 저장됩니다.


# 🔁 Custom Hook in React

## 📌 개요

- Custom Hook은 이름이 `use`로 시작하고, 내부에서 다른 Hook을 호출하는 하나의 자바스크립트 함수입니다.
- 여러 컴포넌트에서 공통적으로 필요한 로직을 추출하여 **코드의 중복을 줄이고**, **유지보수를 용이하게** 합니다.
- 반복적으로 사용되는 로직을 **재사용 가능하도록 추출한 함수**입니다.
- React의 기본 Hook(`useState`, `useEffect`, `useRef` 등)을 조합하여 **새로운 기능을 만들 수 있습니다.**
- `use`로 시작하는 이름을 **반드시 사용해야 합니다.**
- 내부에서 React의 다른 Hook을 **자유롭게 사용할 수 있습니다.**
- 컴포넌트가 아닌 **일반 함수이므로**, 렌더링과 관련 없는 로직도 포함할 수 있습니다.
- Custom Hook을 활용하면 React 애플리케이션에서 **반복되는 로직을 재사용 가능하게 분리할 수 있습니다.**
- 컴포넌트의 복잡도를 줄이고, 유지보수를 쉽게 만들기 위해 **적극적으로 활용하는 것이 좋습니다!**

---

