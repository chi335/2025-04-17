# 📘 React Hooks 정리

## 🔹 useState()

> `useState`는 React 함수형 컴포넌트에서 상태(state)를 관리할 수 있도록 해주는 Hook입니다.

- 클래스형 컴포넌트의 `this.state`와 `this.setState`를 대체합니다.
- 상태 변수를 선언하고 해당 상태를 업데이트하는 함수를 제공합니다.
- 컴포넌트가 렌더링될 때마다 상태를 유지합니다.
- 변수 각각에 대한 `set` 함수가 따로 존재합니다.

### useState 관련 용어

- **state**: 현재 상태 값  
  `useState`로 관리되는 상태 값입니다. 이 값은 컴포넌트에서 언제든지 접근할 수 있습니다.

- **setState**: 상태를 변경하는 함수  
  `setState` 함수는 상태 값을 업데이트하는 데 사용됩니다. 상태 변경 시 컴포넌트가 리렌더링됩니다.

- **initialValue**: 상태의 초기 값  
  `useState`에 전달되는 첫 번째 인자는 상태의 초기 값입니다. 이 값은 컴포넌트가 처음 렌더링될 때 사용됩니다.


### 상태 관리 예시

| 기능               | 코드 예시                                       |
|--------------------|------------------------------------------------|
| **기본 사용**      | `const [state, setState] = useState(초기값);`   |
| **상태 변경**      | `setState(새로운 값)`                           |
| **객체 상태 관리** | `setState(prev => ({ ...prev, 변경값 }))`      |
| **배열 상태 관리** | `setState([...배열, 새 요소])`                 |
| **함수형 업데이트**| `setState(prev => prev + 1)`                   


### useMemo()

`useMemo`는 계산 비용이 큰 연산의 결과를 메모이제이션하여 성능을 최적화하는 Hook입니다.

#### ✅ 사용해야 하는 경우
- 연산 비용이 큰 계산을 반복할 때
- 객체 또는 배열이 불필요하게 재생성될 때
- 의존성이 변경되지 않는 한 동일한 값을 유지해야 할 때

#### ❌ 사용하지 않아도 되는 경우
- 간단한 연산
- 값이 자주 바뀌는 경우 (오히려 성능 저하 가능)
- `useEffect`와 혼동하여 잘못 사용하는 경우

#### ⚠️ 사용 시 주의사항
- 과도한 사용은 오히려 성능 저하를 유발할 수 있습니다.
- 의존성 배열을 정확하게 지정할 것


### Custom Hook

`Custom Hook`은 `use`로 시작하며 내부에서 다른 Hook을 사용하는 JavaScript 함수입니다.

여러 컴포넌트에서 공통적으로 필요한 로직을 추출하여 코드 중복을 줄이고 유지보수를 용이하게 합니다.

React의 기본 Hook (`useState`, `useEffect`, `useRef` 등)을 조합하여 새로운 기능을 만들 수 있습니다.

컴포넌트가 아닌 일반 함수이며, 렌더링과 관련 없는 로직도 포함할 수 있습니다.

#### ✅ 특징 요약
- 이름은 반드시 `use`로 시작해야 함
- React의 다른 Hook들을 내부에서 사용할 수 있음
- 반복되는 로직을 쉽게 재사용할 수 있음
- 컴포넌트의 복잡도를 줄이고 구조를 더 명확하게 유지 가능


### ✨ React의 Hooks

React의 Hooks는 코드의 가독성과 유지보수를 향상시키는 강력한 도구입니다.
